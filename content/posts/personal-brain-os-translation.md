---
title: "文件系统即数据库：我如何为 AI Agent 构建个人操作系统"
date: 2026-02-23T16:00:00Z
draft: false
tags: ["AI", "Context Engineering", "Agent", "Translation", "Personal OS"]
categories: ["AI 前沿"]
description: "全译 Muratcan Koylan 的爆款长文。用 Git 仓库 + 80+ 个 Markdown/YAML/JSONL 文件，打造一套让 AI 真正了解你的个人操作系统。"
cover:
    image: "images/personal-brain-os-cover.png"
    alt: "Personal Brain OS"
    caption: "文件系统即数据库"
---

> **译者注**：本文翻译自 Muratcan Koylan（[@koylanai](https://x.com/koylanai)）于 2026 年 2 月 21 日发布的长文 *[The File System Is the New Database](https://x.com/koylanai/status/2025286163641118915)*。发布后迅速获得 110 万浏览、4000+ 点赞、12000+ 收藏。作者是 Sully.ai 的 Context Engineer，其开源 Context Engineering 框架在 GitHub 获得 8000+ Star。

---
<!--more-->

每次 AI 对话都从同一个地方开始：你解释自己是谁，你在做什么，你粘贴进风格指南，你重新描述你的目标。你把昨天给过的上下文再给一遍，前天的再给一遍。然后，40 分钟后，模型忘记了你的语气，开始写得像新闻稿。

我受够了。所以我构建了一套系统来解决这个问题。

我称之为 **Personal Brain OS**（个人大脑操作系统）。这是一套基于文件的个人操作系统，存活在一个 Git 仓库里。克隆它，在 Cursor 或 Claude Code 中打开，AI 助手就拥有了一切：我的语气、我的品牌、我的目标、我的联系人、我的内容管道、我的研究、我的失败记录。

无需数据库，无需 API Key，无需构建步骤。只有 80+ 个 Markdown、YAML 和 JSONL 文件——人类和语言模型都能原生读取。

我将分享完整的架构、设计决策和踩过的坑，让你能构建自己的版本。不是我的复制品，而是你的。具体的模块、文件 Schema、技能定义会因你的工作而不同。但模式是可迁移的。为 AI Agent 构建信息结构的原则是通用的。

---

## 1）核心问题：上下文，而非提示词

大多数人认为 AI 助手的瓶颈在于提示词工程。写更好的提示词，得到更好的答案。对于单次交互，这是对的。但当你想让 AI 在数周乃至数月内跨越数十个任务、以你的身份运作时，这套逻辑就崩了。

**注意力预算**：语言模型有有限的上下文窗口，而且并非所有位置都同等重要。这意味着把你知道的一切都塞进系统提示词，不仅是浪费，还会主动降低性能。你添加的每一个 token 都在争夺模型的注意力。

我们的大脑也类似。当有人在会议前给你做 15 分钟简报，你会记住他们说的第一件事和最后一件事，中间的模糊了。语言模型有同样的 U 形注意力曲线，只不过它们的是数学上可测量的。Token 位置影响召回概率。新模型在改善，但你仍然在分散模型对最重要事物的注意力。

了解这一点，会改变你为 AI 系统设计信息架构的方式。

**模块化而非单一巨型提示词**：我没有写一个庞大的系统提示词，而是将 Personal OS 拆分成 11 个独立模块。当我让 AI 写博客时，它加载我的语气指南和品牌文件。当我让它准备会议时，它加载我的联系人数据库和互动历史。模型在内容任务期间永远看不到网络数据，在会议准备任务期间永远看不到内容模板。

**渐进式披露**：这是让整个系统运转的架构模式。我没有一次性加载所有 80+ 个文件，而是使用三个层级：

- **Level 1**：一个轻量级路由文件，始终加载。它告诉 AI 哪个模块是相关的。
- **Level 2**：模块专属指令，仅在需要该模块时加载。
- **Level 3**：实际数据——JSONL 日志、YAML 配置、研究文档，仅在任务需要时加载。

这三个层级创建了一个漏斗：广泛路由 → 模块上下文 → 具体数据。在每一步，模型都拥有它所需要的，仅此而已。

我的路由文件是 `SKILL.md`，它告诉 Agent "这是内容任务，加载品牌模块"或"这是网络任务，加载联系人"。模块指令文件（`CONTENT.md`、`OPERATIONS.md`、`NETWORK.md`）每个 40-100 行，包含文件清单、工作流序列和行为规则的 `<instructions>` 块。数据文件最后加载，仅在需要时。AI 逐行读取联系人，而不是解析整个文件。三个层级，到任何信息最多两跳。

**Agent 指令层级**：我构建了三层指令，在不同层级限定 AI 的行为范围：

- **仓库层**：`CLAUDE.md` 是入职文档——每个 AI 工具首先读取它，获得项目的完整地图。
- **大脑层**：`AGENT.md` 包含七条核心规则和一个决策表，将常见请求映射到精确的行动序列。
- **模块层**：每个目录都有自己的指令文件，包含领域专属的行为约束。

这解决了大型 AI 项目中普遍存在的"指令冲突"问题。当所有内容都在一个系统提示词里时，规则会相互矛盾。通过将规则限定在其领域，你消除了冲突，给 Agent 提供了清晰、不重叠的指导。

---

## 2）文件系统即记忆

我做出的最反直觉的决定之一：**不用数据库**。没有向量存储，没有检索系统，只有磁盘上的文件，用 Git 版本控制。

**格式-功能映射**：系统中的每种文件格式都因特定原因而被选择：

- **JSONL 用于日志**：天然追加写入，流式友好（Agent 逐行读取，无需解析整个文件），每行都是独立的有效 JSON。
- **YAML 用于配置**：干净处理层级数据，支持注释，人类和机器都可读，没有 JSON 括号的噪音。
- **Markdown 用于叙述**：LLM 原生读取，到处都能渲染，在 Git 中产生干净的 diff。

JSONL 的追加写入特性防止了一类 bug——Agent 意外覆盖历史数据。我见过这种情况发生在 JSON 文件上：Agent 写入整个文件，丢失了三个月的联系人历史。用 JSONL，Agent 只能添加行。删除通过将条目标记为 `"status": "archived"` 来完成，保留完整历史以供模式分析。

我的系统使用 11 个 JSONL 文件（帖子、联系人、互动、书签、想法、指标、经历、决策、失败、参与度、会议），6 个 YAML 文件（目标、价值观、学习、圈子、节奏、启发式），以及 50+ 个 Markdown 文件（语气指南、研究、模板、草稿、待办）。每个 JSONL 文件都以 Schema 行开头：`{"_schema": "contact", "_version": "1.0", "_description": "..."}`。Agent 在读取数据之前始终知道结构。

**情节记忆**：大多数"第二大脑"系统存储事实。我的还存储判断。`memory/` 模块包含三个追加写入日志：

- `experiences.jsonl`：关键时刻，带有 1-10 的情感权重评分
- `decisions.jsonl`：关键决策，包含推理、考虑的替代方案和追踪的结果
- `failures.jsonl`：出了什么问题、根本原因和预防步骤

拥有你的文件的 AI 和拥有你的判断的 AI 之间有区别。事实告诉 Agent 发生了什么。情节记忆告诉 Agent 什么是重要的、我会怎么做不同、以及我如何权衡取舍。

**跨模块引用**：系统使用扁平文件关系模型。没有数据库，但结构化程度足以让 Agent 跨文件连接数据。`interactions.jsonl` 中的 `contact_id` 指向 `contacts.jsonl` 中的条目。`ideas.jsonl` 中的 `pillar` 映射到 `identity/brand.md` 中定义的内容支柱。书签喂给内容想法，帖子指标喂给每周回顾。

---

## 3）技能系统：教 AI 如何做你的工作

文件存储知识。技能编码流程。我按照 Anthropic Agent Skills 标准构建了 Agent 技能——结构化指令，告诉 AI 如何执行特定任务，并内置质量关卡。

**自动加载 vs. 手动调用**：两种类型的技能解决两个不同的问题：

- **参考技能**（`voice-guide`、`writing-anti-patterns`）在 YAML 前置元数据中设置 `user-invocable: false`。Agent 读取描述字段，在任务涉及写作时自动注入它们。我从不调用它们，它们每次都静默激活。
- **任务技能**（`/write-blog`、`/topic-research`、`/content-workflow`）设置 `disable-model-invocation: true`。Agent 不能自行触发它们。我输入斜杠命令，技能就成为 Agent 该任务的完整指令集。

自动加载解决了一致性问题。我不必每次要草稿时都记得说"用我的语气"。手动调用解决了精确性问题。研究任务有不同于博客文章的质量关卡。

当我输入 `/write-blog context engineering for marketing teams` 时，五件事自动发生：语气指南加载（我如何写作），反模式加载（我绝不写什么），博客模板加载（7 节结构，带字数目标），检查 persona 文件夹中的受众画像，检查研究文件夹中的现有主题研究。一个斜杠命令触发完整的上下文组装。

**语气系统**：我的语气被编码为结构化数据。语气档案在五个维度上用 1-10 评分：正式/随意（6）、严肃/活泼（4）、技术/简单（7）、保守/表达（6）、谦逊/自信（7）。反模式文件包含三个层级的 50+ 个禁用词、禁用开头、结构陷阱（强制三段论、系动词回避、过度对冲），以及每段最多一个破折号的硬性限制。

大多数人用形容词描述自己的语气："专业但平易近人。"这对 AI 毫无用处。技术/简单维度的 7 分精确告诉模型该落在哪里。禁用词列表更强大——定义你不是什么比定义你是什么更容易。

---

## 4）操作系统：我如何在日常中使用它

**内容管道**：七个阶段——想法、研究、大纲、草稿、编辑、发布、推广。

- 想法被捕获到 `ideas.jsonl`，带有评分系统：每个想法在定位契合度、独特洞见、受众需求、时效性、努力与影响比上评 1-5 分。总分达到 15 或以上才推进。
- 研究输出到知识模块。
- 草稿经过四轮编辑。
- 发布内容记录到 `posts.jsonl`，包含平台、URL 和参与度指标。
- 推广使用线程模板创建 X 公告和 LinkedIn 改编版。

我在周日批量创作内容：3-4 小时，目标产出 3-4 篇草稿和大纲。

**个人 CRM**：联系人按四个圈子组织，维护节奏不同：内圈（每周）、活跃（每两周）、网络（每月）、休眠（每季度重新激活）。每条联系人记录都有 `can_help_with` 和 `you_can_help_with` 字段，支持介绍匹配系统。互动记录带有情感追踪（积极、中性、需要关注），让关系健康状况一目了然。

**自动化链**：五个脚本处理重复工作流。周日每周回顾按顺序运行三个脚本：`metrics_snapshot.py` 更新数字，`stale_contacts.py` 标记关系，`weekly_review.py` 生成摘要文档，包含完成与计划对比、指标趋势和下周优先级。

---

## 5）我犯的错误和我会怎么做不同

- **第一版过度设计了 Schema**：我最初的 JSONL Schema 每条记录有 15+ 个字段，大多数是空的。Agent 在处理稀疏数据时会挣扎——它们试图填充字段或评论字段的缺失。我将 Schema 削减到 8-10 个必要字段，只在实际有数据时才添加可选字段。更简单的 Schema，更好的 Agent 行为。

- **语气指南太长**：第一版 `tone-of-voice.md` 有 1200 行。Agent 开头表现良好，然后到第四段就漂移了，因为语气指令落入了"迷失在中间"区域。我重构它，将最独特的模式（标志性短语、禁用词、开头模式）前置到前 100 行，扩展示例放在后面。关键规则需要在顶部，而不是中间。

- **模块边界比你想象的更重要**：我最初将身份和品牌放在一个模块里。Agent 在只需要禁用词列表时会加载我的整个简历。将它们拆分成两个模块，将仅语气任务的 token 使用量减少了 40%。每个模块边界都是一个加载决策。搞错了，你要么加载太多，要么太少。

- **追加写入是不可妥协的**：早期我因为 Agent 重写了 `posts.jsonl` 而不是追加，丢失了三个月的帖子参与数据。JSONL 的追加写入模式不只是惯例——它是一种安全机制。Agent 可以添加数据，不能销毁数据。这是系统中最重要的架构决策。

---

## 6）结果与背后的原则

真正的结果比任何指标都简单。我打开 Cursor 或 Claude Code，开始对话，AI 已经知道我是谁、我如何写作、我在做什么、我关心什么。它用我的语气写作，因为我的语气被编码为结构化数据。它遵循我的优先级，因为我的目标在它建议下周工作内容之前读取的 YAML 文件里。它管理我的关系，因为我的联系人和互动在它可以查询的文件里。

这背后的原则：**这是上下文工程，而非提示词工程。**

提示词工程问的是"我如何更好地措辞这个问题？"上下文工程问的是"这个 AI 需要什么信息才能做出正确决策，以及我如何构建这些信息让模型真正使用它？"

转变是从优化单次交互到设计信息架构。这是写一封好邮件和建立一个好归档系统之间的区别。前者帮你一次，后者每次都帮你。

整个系统放在一个 Git 仓库里。克隆到任何机器，将任何 AI 工具指向它，操作系统就运行起来了。零依赖，完全可移植。因为是 Git，每次变更都有版本，每个决策都可追溯，没有什么是真正丢失的。

---

*Muratcan Koylan 是 [Sully.ai](https://sully.ai) 的 Context Engineer，为医疗 AI 设计上下文工程系统。他在上下文工程方面的开源工作（8000+ GitHub Star）被学术研究引用。框架开源地址：[Agent Skills for Context Engineering](https://github.com/muratcankoylan/Agent-Skills-for-Context-Engineering)*
