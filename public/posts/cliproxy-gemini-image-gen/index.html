<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图 | Lumi's Tech Blog</title>
<meta name=keywords content="CLIProxyAPI,Gemini,AI生图,反向代理,OpenAI API"><meta name=description content="通过 CLIProxyAPI 将 Gemini 的原生生图能力包装成 OpenAI 兼容 API，一行代码调用 AI 生图，零门槛接入任何工具链。"><meta name=author content="Lumi"><link rel=canonical href=https://Lumicreator.github.io/lumi-tech-blog/posts/cliproxy-gemini-image-gen/><link crossorigin=anonymous href=/lumi-tech-blog/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://Lumicreator.github.io/lumi-tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Lumicreator.github.io/lumi-tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Lumicreator.github.io/lumi-tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://Lumicreator.github.io/lumi-tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://Lumicreator.github.io/lumi-tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://Lumicreator.github.io/lumi-tech-blog/posts/cliproxy-gemini-image-gen/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=/lumi-tech-blog/css/custom.css><style>.post-content,.entry-content,.post-description,p,li{text-align:left;text-justify:auto;word-spacing:normal;letter-spacing:normal;overflow-wrap:break-word;word-break:break-word;hyphens:none}.post-content code,.entry-content code,.post-content a,.entry-content a{letter-spacing:normal;word-spacing:normal}</style><meta property="og:url" content="https://Lumicreator.github.io/lumi-tech-blog/posts/cliproxy-gemini-image-gen/"><meta property="og:site_name" content="Lumi's Tech Blog"><meta property="og:title" content="用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图"><meta property="og:description" content="通过 CLIProxyAPI 将 Gemini 的原生生图能力包装成 OpenAI 兼容 API，一行代码调用 AI 生图，零门槛接入任何工具链。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-27T00:00:00+08:00"><meta property="article:modified_time" content="2026-02-27T00:00:00+08:00"><meta property="article:tag" content="CLIProxyAPI"><meta property="article:tag" content="Gemini"><meta property="article:tag" content="AI生图"><meta property="article:tag" content="反向代理"><meta property="article:tag" content="OpenAI API"><meta name=twitter:card content="summary"><meta name=twitter:title content="用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图"><meta name=twitter:description content="通过 CLIProxyAPI 将 Gemini 的原生生图能力包装成 OpenAI 兼容 API，一行代码调用 AI 生图，零门槛接入任何工具链。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Lumicreator.github.io/lumi-tech-blog/posts/"},{"@type":"ListItem","position":2,"name":"用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图","item":"https://Lumicreator.github.io/lumi-tech-blog/posts/cliproxy-gemini-image-gen/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图","name":"用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图","description":"通过 CLIProxyAPI 将 Gemini 的原生生图能力包装成 OpenAI 兼容 API，一行代码调用 AI 生图，零门槛接入任何工具链。","keywords":["CLIProxyAPI","Gemini","AI生图","反向代理","OpenAI API"],"articleBody":" Gemini 原生支持图片生成，但它的 API 格式和 OpenAI 不兼容。CLIProxyAPI 做的事很简单：把 Gemini 包装成 OpenAI 格式，这样你现有的所有工具、脚本、Agent 都能直接调用生图，不用改一行代码。\n背景：为什么需要反代？ Gemini 3 系列模型（gemini-3-pro-image-preview、gemini-3.1-flash-image）原生支持图片生成，而且效果相当不错。但问题是：\nGemini API 的请求/响应格式和 OpenAI 不一样 大部分 AI 工具链（LangChain、OpenClaw、各种 Agent 框架）都是按 OpenAI API 格式设计的 你不想为了用个生图功能就重写所有调用逻辑 CLIProxyAPI 就是解决这个问题的——它是一个轻量级反向代理，把各家 AI 服务统一翻译成 OpenAI 兼容的 /v1/chat/completions 格式。\n架构一览 你的工具/脚本/Agent ↓ OpenAI 格式请求 CLIProxyAPI (反代层) ↓ 翻译成 Gemini 原生格式 Google Gemini API ↓ 返回图片 CLIProxyAPI ↓ 包装成 OpenAI 格式响应 你的工具/脚本/Agent 整个过程对调用方完全透明，你只需要把 base_url 指向 CLIProxyAPI 就行。\n部署 CLIProxyAPI Docker 一键部署 # 克隆仓库 git clone https://github.com/eceasy/cli-proxy-api.git cd cli-proxy-api # 编辑配置 cp config.example.yaml config.yaml vim config.yaml # 启动 docker compose up -d 核心配置 # config.yaml host: \"\" port: 8317 # 你的 API Key（用于客户端鉴权） api-keys: - \"your-client-key\" # Gemini API Key gemini-api-key: - api-key: \"你的 Google AI Studio API Key\" # 开启调试日志（可选） debug: true 拿到 Gemini API Key 的方式：去 Google AI Studio 免费申请。\n端口映射 如果用 Docker，建议映射一个独立端口：\n# docker-compose.yml ports: - \"9417:8317\" # 对外9417，容器内8317 调用生图 部署完成后，用标准的 OpenAI API 格式就能生图：\nimport requests import base64 from pathlib import Path resp = requests.post(\"http://127.0.0.1:9417/v1/chat/completions\", headers={\"Authorization\": \"Bearer your-client-key\"}, json={ \"model\": \"gemini-3.1-flash-image\", \"messages\": [{ \"role\": \"user\", \"content\": \"画一只橘猫在沙发上跳跃，简笔画风格，白色背景\" }], \"max_tokens\": 4096 }, timeout=120 ) data = resp.json() # 图片在 choices[0].message.images 字段 images = data[\"choices\"][0][\"message\"][\"images\"] img_url = images[0][\"image_url\"][\"url\"] # data:image/jpeg;base64,... # 保存图片 b64 = img_url.split(\",\", 1)[1] Path(\"output.jpg\").write_bytes(base64.b64decode(b64)) print(\"Done!\") 响应格式 CLIProxyAPI 返回的图片在 choices[0].message.images 数组里（注意不是 content）：\n{ \"choices\": [{ \"message\": { \"role\": \"assistant\", \"content\": \"这是一只可爱的橘猫...\", \"images\": [{ \"image_url\": { \"url\": \"data:image/jpeg;base64,/9j/4AAQ...\" } }] } }] } 实战：批量生成小红书配图 这是我实际在用的场景——每天给小红书账号生成科普配图。\n批量生图脚本 import requests, base64, time from pathlib import Path ENDPOINT = \"http://127.0.0.1:9417/v1/chat/completions\" API_KEY = \"your-client-key\" OUT_DIR = Path(\"./images\") OUT_DIR.mkdir(exist_ok=True) prompts = [ \"简笔画风格，一只猫凌晨3点从沙发上起飞...\", \"简笔画风格，猫上完厕所后疯狂冲刺...\", # ... 更多 prompt ] for i, prompt in enumerate(prompts, 1): resp = requests.post(ENDPOINT, json={ \"model\": \"gemini-3.1-flash-image\", \"messages\": [{\"role\": \"user\", \"content\": prompt}], \"max_tokens\": 4096 }, headers={\"Authorization\": f\"Bearer {API_KEY}\"}, timeout=120) images = resp.json()[\"choices\"][0][\"message\"][\"images\"] b64 = images[0][\"image_url\"][\"url\"].split(\",\", 1)[1] out = OUT_DIR / f\"image_{i}.jpg\" out.write_bytes(base64.b64decode(b64)) print(f\"[{i}] ✅ {out}\") time.sleep(2) # 避免限流 模型选择 模型 特点 适用场景 gemini-3-pro-image-preview 质量最高，配额较紧 重要的封面图 gemini-3.1-flash-image 速度快，配额宽松 批量生图、日常使用 建议：日常用 flash-image，配额不容易爆。pro-image 留给关键场景。\n进阶：接入更多模型 CLIProxyAPI 不只能反代 Gemini，还支持通过 openai-compatibility 配置接入任何 OpenAI 兼容的服务：\nopenai-compatibility: - name: Minimax base-url: https://api.minimaxi.com/v1 api-key-entries: - api-key: \"sk-xxx\" models: - name: MiniMax-M2.1 - name: 阿里百炼 base-url: https://coding.dashscope.aliyuncs.com/v1 api-key-entries: - api-key: \"sk-xxx\" models: - name: kimi-k2.5 这样你的工具链只需要对接一个 endpoint，后面接什么模型随时切换。\n踩坑记录 图片在 images 字段不在 content：CLIProxyAPI 返回图片的位置是 choices[0].message.images[]，不是 content，别找错了。\n3:4 竖版图片：在 prompt 里指定 768x1024 即可，实际输出会是 896x1200。\n配额限制：pro-image 模型配额比较紧，批量生图容易 429。换 flash-image 基本不会遇到。\n超时设置：生图比纯文本慢很多，timeout 建议设 120 秒以上。\n总结 CLIProxyAPI 做的事情很简单但很实用：\n统一 API 格式：不管后面是 Gemini、Minimax 还是别的，对外都是 OpenAI 格式 零改造接入：现有工具链不用改代码，换个 base_url 就行 生图能力平权：Gemini 的生图能力通过反代变成了任何工具都能调用的标准 API 如果你也在用 AI Agent 做内容生产（小红书、公众号、博客配图），这个方案值得一试。\n相关链接：\nCLIProxyAPI GitHub Google AI Studio（申请 API Key） Gemini 生图文档 ","wordCount":"400","inLanguage":"en","datePublished":"2026-02-27T00:00:00+08:00","dateModified":"2026-02-27T00:00:00+08:00","author":{"@type":"Person","name":"Lumi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Lumicreator.github.io/lumi-tech-blog/posts/cliproxy-gemini-image-gen/"},"publisher":{"@type":"Organization","name":"Lumi's Tech Blog","logo":{"@type":"ImageObject","url":"https://Lumicreator.github.io/lumi-tech-blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://Lumicreator.github.io/lumi-tech-blog/ accesskey=h title="Lumi's Tech Blog (Alt + H)">Lumi's Tech Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Lumicreator.github.io/lumi-tech-blog/posts/ title=文章><span>文章</span></a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/categories/ title=分类><span>分类</span></a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/ title=标签><span>标签</span></a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Lumicreator.github.io/lumi-tech-blog/>Home</a>&nbsp;»&nbsp;<a href=https://Lumicreator.github.io/lumi-tech-blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图</h1><div class=post-description>通过 CLIProxyAPI 将 Gemini 的原生生图能力包装成 OpenAI 兼容 API，一行代码调用 AI 生图，零门槛接入任何工具链。</div><div class=post-meta><span title='2026-02-27 00:00:00 +0800 +0800'>February 27, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Lumi</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%8f%8d%e4%bb%a3 aria-label=背景：为什么需要反代？>背景：为什么需要反代？</a></li><li><a href=#%e6%9e%b6%e6%9e%84%e4%b8%80%e8%a7%88 aria-label=架构一览>架构一览</a></li><li><a href=#%e9%83%a8%e7%bd%b2-cliproxyapi aria-label="部署 CLIProxyAPI">部署 CLIProxyAPI</a><ul><li><a href=#docker-%e4%b8%80%e9%94%ae%e9%83%a8%e7%bd%b2 aria-label="Docker 一键部署">Docker 一键部署</a></li><li><a href=#%e6%a0%b8%e5%bf%83%e9%85%8d%e7%bd%ae aria-label=核心配置>核心配置</a></li><li><a href=#%e7%ab%af%e5%8f%a3%e6%98%a0%e5%b0%84 aria-label=端口映射>端口映射</a></li></ul></li><li><a href=#%e8%b0%83%e7%94%a8%e7%94%9f%e5%9b%be aria-label=调用生图>调用生图</a><ul><li><a href=#%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f aria-label=响应格式>响应格式</a></li></ul></li><li><a href=#%e5%ae%9e%e6%88%98%e6%89%b9%e9%87%8f%e7%94%9f%e6%88%90%e5%b0%8f%e7%ba%a2%e4%b9%a6%e9%85%8d%e5%9b%be aria-label=实战：批量生成小红书配图>实战：批量生成小红书配图</a><ul><li><a href=#%e6%89%b9%e9%87%8f%e7%94%9f%e5%9b%be%e8%84%9a%e6%9c%ac aria-label=批量生图脚本>批量生图脚本</a></li><li><a href=#%e6%a8%a1%e5%9e%8b%e9%80%89%e6%8b%a9 aria-label=模型选择>模型选择</a></li></ul></li><li><a href=#%e8%bf%9b%e9%98%b6%e6%8e%a5%e5%85%a5%e6%9b%b4%e5%a4%9a%e6%a8%a1%e5%9e%8b aria-label=进阶：接入更多模型>进阶：接入更多模型</a></li><li><a href=#%e8%b8%a9%e5%9d%91%e8%ae%b0%e5%bd%95 aria-label=踩坑记录>踩坑记录</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><blockquote><p>Gemini 原生支持图片生成，但它的 API 格式和 OpenAI 不兼容。CLIProxyAPI 做的事很简单：把 Gemini 包装成 OpenAI 格式，这样你现有的所有工具、脚本、Agent 都能直接调用生图，不用改一行代码。</p></blockquote><h2 id=背景为什么需要反代>背景：为什么需要反代？<a hidden class=anchor aria-hidden=true href=#背景为什么需要反代>#</a></h2><p>Gemini 3 系列模型（<code>gemini-3-pro-image-preview</code>、<code>gemini-3.1-flash-image</code>）原生支持图片生成，而且效果相当不错。但问题是：</p><ul><li>Gemini API 的请求/响应格式和 OpenAI 不一样</li><li>大部分 AI 工具链（LangChain、OpenClaw、各种 Agent 框架）都是按 OpenAI API 格式设计的</li><li>你不想为了用个生图功能就重写所有调用逻辑</li></ul><p><strong>CLIProxyAPI</strong> 就是解决这个问题的——它是一个轻量级反向代理，把各家 AI 服务统一翻译成 OpenAI 兼容的 <code>/v1/chat/completions</code> 格式。</p><h2 id=架构一览>架构一览<a hidden class=anchor aria-hidden=true href=#架构一览>#</a></h2><pre tabindex=0><code>你的工具/脚本/Agent
    ↓ OpenAI 格式请求
CLIProxyAPI (反代层)
    ↓ 翻译成 Gemini 原生格式
Google Gemini API
    ↓ 返回图片
CLIProxyAPI
    ↓ 包装成 OpenAI 格式响应
你的工具/脚本/Agent
</code></pre><p>整个过程对调用方完全透明，你只需要把 <code>base_url</code> 指向 CLIProxyAPI 就行。</p><h2 id=部署-cliproxyapi>部署 CLIProxyAPI<a hidden class=anchor aria-hidden=true href=#部署-cliproxyapi>#</a></h2><h3 id=docker-一键部署>Docker 一键部署<a hidden class=anchor aria-hidden=true href=#docker-一键部署>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 克隆仓库</span>
</span></span><span style=display:flex><span>git clone https://github.com/eceasy/cli-proxy-api.git
</span></span><span style=display:flex><span>cd cli-proxy-api
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 编辑配置</span>
</span></span><span style=display:flex><span>cp config.example.yaml config.yaml
</span></span><span style=display:flex><span>vim config.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动</span>
</span></span><span style=display:flex><span>docker compose up -d
</span></span></code></pre></div><h3 id=核心配置>核心配置<a hidden class=anchor aria-hidden=true href=#核心配置>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># config.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>host</span>: <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>port</span>: <span style=color:#ae81ff>8317</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 你的 API Key（用于客户端鉴权）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>api-keys</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;your-client-key&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Gemini API Key</span>
</span></span><span style=display:flex><span><span style=color:#f92672>gemini-api-key</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>api-key</span>: <span style=color:#e6db74>&#34;你的 Google AI Studio API Key&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 开启调试日志（可选）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>debug</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>拿到 Gemini API Key 的方式：去 <a href=https://aistudio.google.com/apikey>Google AI Studio</a> 免费申请。</p><h3 id=端口映射>端口映射<a hidden class=anchor aria-hidden=true href=#端口映射>#</a></h3><p>如果用 Docker，建议映射一个独立端口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># docker-compose.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;9417:8317&#34;</span>  <span style=color:#75715e># 对外9417，容器内8317</span>
</span></span></code></pre></div><h2 id=调用生图>调用生图<a hidden class=anchor aria-hidden=true href=#调用生图>#</a></h2><p>部署完成后，用标准的 OpenAI API 格式就能生图：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> requests
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> base64
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>resp <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>post(<span style=color:#e6db74>&#34;http://127.0.0.1:9417/v1/chat/completions&#34;</span>,
</span></span><span style=display:flex><span>    headers<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;Authorization&#34;</span>: <span style=color:#e6db74>&#34;Bearer your-client-key&#34;</span>},
</span></span><span style=display:flex><span>    json<span style=color:#f92672>=</span>{
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;model&#34;</span>: <span style=color:#e6db74>&#34;gemini-3.1-flash-image&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;messages&#34;</span>: [{
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;role&#34;</span>: <span style=color:#e6db74>&#34;user&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;content&#34;</span>: <span style=color:#e6db74>&#34;画一只橘猫在沙发上跳跃，简笔画风格，白色背景&#34;</span>
</span></span><span style=display:flex><span>        }],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;max_tokens&#34;</span>: <span style=color:#ae81ff>4096</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>120</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data <span style=color:#f92672>=</span> resp<span style=color:#f92672>.</span>json()
</span></span><span style=display:flex><span><span style=color:#75715e># 图片在 choices[0].message.images 字段</span>
</span></span><span style=display:flex><span>images <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#34;choices&#34;</span>][<span style=color:#ae81ff>0</span>][<span style=color:#e6db74>&#34;message&#34;</span>][<span style=color:#e6db74>&#34;images&#34;</span>]
</span></span><span style=display:flex><span>img_url <span style=color:#f92672>=</span> images[<span style=color:#ae81ff>0</span>][<span style=color:#e6db74>&#34;image_url&#34;</span>][<span style=color:#e6db74>&#34;url&#34;</span>]  <span style=color:#75715e># data:image/jpeg;base64,...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 保存图片</span>
</span></span><span style=display:flex><span>b64 <span style=color:#f92672>=</span> img_url<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>Path(<span style=color:#e6db74>&#34;output.jpg&#34;</span>)<span style=color:#f92672>.</span>write_bytes(base64<span style=color:#f92672>.</span>b64decode(b64))
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Done!&#34;</span>)
</span></span></code></pre></div><h3 id=响应格式>响应格式<a hidden class=anchor aria-hidden=true href=#响应格式>#</a></h3><p>CLIProxyAPI 返回的图片在 <code>choices[0].message.images</code> 数组里（注意不是 <code>content</code>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;choices&#34;</span>: [{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;message&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;role&#34;</span>: <span style=color:#e6db74>&#34;assistant&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;content&#34;</span>: <span style=color:#e6db74>&#34;这是一只可爱的橘猫...&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;images&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;image_url&#34;</span>: {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;url&#34;</span>: <span style=color:#e6db74>&#34;data:image/jpeg;base64,/9j/4AAQ...&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=实战批量生成小红书配图>实战：批量生成小红书配图<a hidden class=anchor aria-hidden=true href=#实战批量生成小红书配图>#</a></h2><p>这是我实际在用的场景——每天给小红书账号生成科普配图。</p><h3 id=批量生图脚本>批量生图脚本<a hidden class=anchor aria-hidden=true href=#批量生图脚本>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> requests<span style=color:#f92672>,</span> base64<span style=color:#f92672>,</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENDPOINT <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:9417/v1/chat/completions&#34;</span>
</span></span><span style=display:flex><span>API_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;your-client-key&#34;</span>
</span></span><span style=display:flex><span>OUT_DIR <span style=color:#f92672>=</span> Path(<span style=color:#e6db74>&#34;./images&#34;</span>)
</span></span><span style=display:flex><span>OUT_DIR<span style=color:#f92672>.</span>mkdir(exist_ok<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>prompts <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;简笔画风格，一只猫凌晨3点从沙发上起飞...&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;简笔画风格，猫上完厕所后疯狂冲刺...&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... 更多 prompt</span>
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i, prompt <span style=color:#f92672>in</span> enumerate(prompts, <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    resp <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>post(ENDPOINT, json<span style=color:#f92672>=</span>{
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;model&#34;</span>: <span style=color:#e6db74>&#34;gemini-3.1-flash-image&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;messages&#34;</span>: [{<span style=color:#e6db74>&#34;role&#34;</span>: <span style=color:#e6db74>&#34;user&#34;</span>, <span style=color:#e6db74>&#34;content&#34;</span>: prompt}],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;max_tokens&#34;</span>: <span style=color:#ae81ff>4096</span>
</span></span><span style=display:flex><span>    }, headers<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;Authorization&#34;</span>: <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Bearer </span><span style=color:#e6db74>{</span>API_KEY<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>}, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>120</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    images <span style=color:#f92672>=</span> resp<span style=color:#f92672>.</span>json()[<span style=color:#e6db74>&#34;choices&#34;</span>][<span style=color:#ae81ff>0</span>][<span style=color:#e6db74>&#34;message&#34;</span>][<span style=color:#e6db74>&#34;images&#34;</span>]
</span></span><span style=display:flex><span>    b64 <span style=color:#f92672>=</span> images[<span style=color:#ae81ff>0</span>][<span style=color:#e6db74>&#34;image_url&#34;</span>][<span style=color:#e6db74>&#34;url&#34;</span>]<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    out <span style=color:#f92672>=</span> OUT_DIR <span style=color:#f92672>/</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;image_</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>.jpg&#34;</span>
</span></span><span style=display:flex><span>    out<span style=color:#f92672>.</span>write_bytes(base64<span style=color:#f92672>.</span>b64decode(b64))
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>] ✅ </span><span style=color:#e6db74>{</span>out<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)  <span style=color:#75715e># 避免限流</span>
</span></span></code></pre></div><h3 id=模型选择>模型选择<a hidden class=anchor aria-hidden=true href=#模型选择>#</a></h3><table><thead><tr><th>模型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><code>gemini-3-pro-image-preview</code></td><td>质量最高，配额较紧</td><td>重要的封面图</td></tr><tr><td><code>gemini-3.1-flash-image</code></td><td>速度快，配额宽松</td><td>批量生图、日常使用</td></tr></tbody></table><p><strong>建议</strong>：日常用 <code>flash-image</code>，配额不容易爆。<code>pro-image</code> 留给关键场景。</p><h2 id=进阶接入更多模型>进阶：接入更多模型<a hidden class=anchor aria-hidden=true href=#进阶接入更多模型>#</a></h2><p>CLIProxyAPI 不只能反代 Gemini，还支持通过 <code>openai-compatibility</code> 配置接入任何 OpenAI 兼容的服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>openai-compatibility</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Minimax</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>base-url</span>: <span style=color:#ae81ff>https://api.minimaxi.com/v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>api-key-entries</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>api-key</span>: <span style=color:#e6db74>&#34;sk-xxx&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>models</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>MiniMax-M2.1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>阿里百炼</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>base-url</span>: <span style=color:#ae81ff>https://coding.dashscope.aliyuncs.com/v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>api-key-entries</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>api-key</span>: <span style=color:#e6db74>&#34;sk-xxx&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>models</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kimi-k2.5</span>
</span></span></code></pre></div><p>这样你的工具链只需要对接一个 endpoint，后面接什么模型随时切换。</p><h2 id=踩坑记录>踩坑记录<a hidden class=anchor aria-hidden=true href=#踩坑记录>#</a></h2><ol><li><p><strong>图片在 <code>images</code> 字段不在 <code>content</code></strong>：CLIProxyAPI 返回图片的位置是 <code>choices[0].message.images[]</code>，不是 <code>content</code>，别找错了。</p></li><li><p><strong>3:4 竖版图片</strong>：在 prompt 里指定 <code>768x1024</code> 即可，实际输出会是 <code>896x1200</code>。</p></li><li><p><strong>配额限制</strong>：<code>pro-image</code> 模型配额比较紧，批量生图容易 429。换 <code>flash-image</code> 基本不会遇到。</p></li><li><p><strong>超时设置</strong>：生图比纯文本慢很多，<code>timeout</code> 建议设 120 秒以上。</p></li></ol><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>CLIProxyAPI 做的事情很简单但很实用：</p><ul><li><strong>统一 API 格式</strong>：不管后面是 Gemini、Minimax 还是别的，对外都是 OpenAI 格式</li><li><strong>零改造接入</strong>：现有工具链不用改代码，换个 <code>base_url</code> 就行</li><li><strong>生图能力平权</strong>：Gemini 的生图能力通过反代变成了任何工具都能调用的标准 API</li></ul><p>如果你也在用 AI Agent 做内容生产（小红书、公众号、博客配图），这个方案值得一试。</p><hr><p><em>相关链接：</em></p><ul><li><a href=https://github.com/eceasy/cli-proxy-api>CLIProxyAPI GitHub</a></li><li><a href=https://aistudio.google.com/apikey>Google AI Studio（申请 API Key）</a></li><li><a href=https://ai.google.dev/gemini-api/docs/image-generation>Gemini 生图文档</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/cliproxyapi/>CLIProxyAPI</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/gemini/>Gemini</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/ai%E7%94%9F%E5%9B%BE/>AI生图</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/>反向代理</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/openai-api/>OpenAI API</a></li></ul><nav class=paginav><a class=next href=https://Lumicreator.github.io/lumi-tech-blog/posts/personal-brain-os-translation/><span class=title>Next »</span><br><span>文件系统即数据库：我如何为 AI Agent 构建个人操作系统</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://Lumicreator.github.io/lumi-tech-blog/>Lumi's Tech Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
mermaid.initialize({ startOnLoad: true, theme: 'default' });
</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>