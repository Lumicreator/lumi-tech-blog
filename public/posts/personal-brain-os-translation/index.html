<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>文件系统即数据库：我如何为 AI Agent 构建个人操作系统 | Lumi's Tech Blog</title>
<meta name=keywords content="AI,Context Engineering,Agent,Translation,Personal OS"><meta name=description content="全译 Muratcan Koylan 的爆款长文。用 Git 仓库 + 80+ 个 Markdown/YAML/JSONL 文件，打造一套让 AI 真正了解你的个人操作系统。"><meta name=author content="Lumi"><link rel=canonical href=https://Lumicreator.github.io/lumi-tech-blog/posts/personal-brain-os-translation/><link crossorigin=anonymous href=/lumi-tech-blog/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://Lumicreator.github.io/lumi-tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Lumicreator.github.io/lumi-tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Lumicreator.github.io/lumi-tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://Lumicreator.github.io/lumi-tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://Lumicreator.github.io/lumi-tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://Lumicreator.github.io/lumi-tech-blog/posts/personal-brain-os-translation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=/lumi-tech-blog/css/custom.css><style>.post-content,.entry-content,.post-description,p,li{text-align:left;text-justify:auto;word-spacing:normal;letter-spacing:normal;overflow-wrap:break-word;word-break:break-word;hyphens:none}.post-content code,.entry-content code,.post-content a,.entry-content a{letter-spacing:normal;word-spacing:normal}</style><meta property="og:url" content="https://Lumicreator.github.io/lumi-tech-blog/posts/personal-brain-os-translation/"><meta property="og:site_name" content="Lumi's Tech Blog"><meta property="og:title" content="文件系统即数据库：我如何为 AI Agent 构建个人操作系统"><meta property="og:description" content="全译 Muratcan Koylan 的爆款长文。用 Git 仓库 + 80+ 个 Markdown/YAML/JSONL 文件，打造一套让 AI 真正了解你的个人操作系统。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-23T16:00:00+00:00"><meta property="article:modified_time" content="2026-02-23T16:00:00+00:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="Context Engineering"><meta property="article:tag" content="Agent"><meta property="article:tag" content="Translation"><meta property="article:tag" content="Personal OS"><meta property="og:image" content="https://Lumicreator.github.io/lumi-tech-blog/images/personal-brain-os-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://Lumicreator.github.io/lumi-tech-blog/images/personal-brain-os-cover.png"><meta name=twitter:title content="文件系统即数据库：我如何为 AI Agent 构建个人操作系统"><meta name=twitter:description content="全译 Muratcan Koylan 的爆款长文。用 Git 仓库 + 80+ 个 Markdown/YAML/JSONL 文件，打造一套让 AI 真正了解你的个人操作系统。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Lumicreator.github.io/lumi-tech-blog/posts/"},{"@type":"ListItem","position":2,"name":"文件系统即数据库：我如何为 AI Agent 构建个人操作系统","item":"https://Lumicreator.github.io/lumi-tech-blog/posts/personal-brain-os-translation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"文件系统即数据库：我如何为 AI Agent 构建个人操作系统","name":"文件系统即数据库：我如何为 AI Agent 构建个人操作系统","description":"全译 Muratcan Koylan 的爆款长文。用 Git 仓库 + 80+ 个 Markdown/YAML/JSONL 文件，打造一套让 AI 真正了解你的个人操作系统。","keywords":["AI","Context Engineering","Agent","Translation","Personal OS"],"articleBody":" 译者注：本文翻译自 Muratcan Koylan（@koylanai）于 2026 年 2 月 21 日发布的长文 The File System Is the New Database。发布后迅速获得 110 万浏览、4000+ 点赞、12000+ 收藏。作者是 Sully.ai 的 Context Engineer，其开源 Context Engineering 框架在 GitHub 获得 8000+ Star。\n每次 AI 对话都从同一个地方开始：你解释自己是谁，你在做什么，你粘贴进风格指南，你重新描述你的目标。你把昨天给过的上下文再给一遍，前天的再给一遍。然后，40 分钟后，模型忘记了你的语气，开始写得像新闻稿。\n我受够了。所以我构建了一套系统来解决这个问题。\n我称之为 Personal Brain OS（个人大脑操作系统）。这是一套基于文件的个人操作系统，存活在一个 Git 仓库里。克隆它，在 Cursor 或 Claude Code 中打开，AI 助手就拥有了一切：我的语气、我的品牌、我的目标、我的联系人、我的内容管道、我的研究、我的失败记录。\n无需数据库，无需 API Key，无需构建步骤。只有 80+ 个 Markdown、YAML 和 JSONL 文件——人类和语言模型都能原生读取。\n我将分享完整的架构、设计决策和踩过的坑，让你能构建自己的版本。不是我的复制品，而是你的。具体的模块、文件 Schema、技能定义会因你的工作而不同。但模式是可迁移的。为 AI Agent 构建信息结构的原则是通用的。\n1）核心问题：上下文，而非提示词 大多数人认为 AI 助手的瓶颈在于提示词工程。写更好的提示词，得到更好的答案。对于单次交互，这是对的。但当你想让 AI 在数周乃至数月内跨越数十个任务、以你的身份运作时，这套逻辑就崩了。\n注意力预算：语言模型有有限的上下文窗口，而且并非所有位置都同等重要。这意味着把你知道的一切都塞进系统提示词，不仅是浪费，还会主动降低性能。你添加的每一个 token 都在争夺模型的注意力。\n我们的大脑也类似。当有人在会议前给你做 15 分钟简报，你会记住他们说的第一件事和最后一件事，中间的模糊了。语言模型有同样的 U 形注意力曲线，只不过它们的是数学上可测量的。Token 位置影响召回概率。新模型在改善，但你仍然在分散模型对最重要事物的注意力。\n了解这一点，会改变你为 AI 系统设计信息架构的方式。\n模块化而非单一巨型提示词：我没有写一个庞大的系统提示词，而是将 Personal OS 拆分成 11 个独立模块。当我让 AI 写博客时，它加载我的语气指南和品牌文件。当我让它准备会议时，它加载我的联系人数据库和互动历史。模型在内容任务期间永远看不到网络数据，在会议准备任务期间永远看不到内容模板。\n渐进式披露：这是让整个系统运转的架构模式。我没有一次性加载所有 80+ 个文件，而是使用三个层级：\nLevel 1：一个轻量级路由文件，始终加载。它告诉 AI 哪个模块是相关的。 Level 2：模块专属指令，仅在需要该模块时加载。 Level 3：实际数据——JSONL 日志、YAML 配置、研究文档，仅在任务需要时加载。 这三个层级创建了一个漏斗：广泛路由 → 模块上下文 → 具体数据。在每一步，模型都拥有它所需要的，仅此而已。\n我的路由文件是 SKILL.md，它告诉 Agent “这是内容任务，加载品牌模块\"或\"这是网络任务，加载联系人”。模块指令文件（CONTENT.md、OPERATIONS.md、NETWORK.md）每个 40-100 行，包含文件清单、工作流序列和行为规则的 块。数据文件最后加载，仅在需要时。AI 逐行读取联系人，而不是解析整个文件。三个层级，到任何信息最多两跳。\nAgent 指令层级：我构建了三层指令，在不同层级限定 AI 的行为范围：\n仓库层：CLAUDE.md 是入职文档——每个 AI 工具首先读取它，获得项目的完整地图。 大脑层：AGENT.md 包含七条核心规则和一个决策表，将常见请求映射到精确的行动序列。 模块层：每个目录都有自己的指令文件，包含领域专属的行为约束。 这解决了大型 AI 项目中普遍存在的\"指令冲突\"问题。当所有内容都在一个系统提示词里时，规则会相互矛盾。通过将规则限定在其领域，你消除了冲突，给 Agent 提供了清晰、不重叠的指导。\n2）文件系统即记忆 我做出的最反直觉的决定之一：不用数据库。没有向量存储，没有检索系统，只有磁盘上的文件，用 Git 版本控制。\n格式-功能映射：系统中的每种文件格式都因特定原因而被选择：\nJSONL 用于日志：天然追加写入，流式友好（Agent 逐行读取，无需解析整个文件），每行都是独立的有效 JSON。 YAML 用于配置：干净处理层级数据，支持注释，人类和机器都可读，没有 JSON 括号的噪音。 Markdown 用于叙述：LLM 原生读取，到处都能渲染，在 Git 中产生干净的 diff。 JSONL 的追加写入特性防止了一类 bug——Agent 意外覆盖历史数据。我见过这种情况发生在 JSON 文件上：Agent 写入整个文件，丢失了三个月的联系人历史。用 JSONL，Agent 只能添加行。删除通过将条目标记为 \"status\": \"archived\" 来完成，保留完整历史以供模式分析。\n我的系统使用 11 个 JSONL 文件（帖子、联系人、互动、书签、想法、指标、经历、决策、失败、参与度、会议），6 个 YAML 文件（目标、价值观、学习、圈子、节奏、启发式），以及 50+ 个 Markdown 文件（语气指南、研究、模板、草稿、待办）。每个 JSONL 文件都以 Schema 行开头：{\"_schema\": \"contact\", \"_version\": \"1.0\", \"_description\": \"...\"}。Agent 在读取数据之前始终知道结构。\n情节记忆：大多数\"第二大脑\"系统存储事实。我的还存储判断。memory/ 模块包含三个追加写入日志：\nexperiences.jsonl：关键时刻，带有 1-10 的情感权重评分 decisions.jsonl：关键决策，包含推理、考虑的替代方案和追踪的结果 failures.jsonl：出了什么问题、根本原因和预防步骤 拥有你的文件的 AI 和拥有你的判断的 AI 之间有区别。事实告诉 Agent 发生了什么。情节记忆告诉 Agent 什么是重要的、我会怎么做不同、以及我如何权衡取舍。\n跨模块引用：系统使用扁平文件关系模型。没有数据库，但结构化程度足以让 Agent 跨文件连接数据。interactions.jsonl 中的 contact_id 指向 contacts.jsonl 中的条目。ideas.jsonl 中的 pillar 映射到 identity/brand.md 中定义的内容支柱。书签喂给内容想法，帖子指标喂给每周回顾。\n3）技能系统：教 AI 如何做你的工作 文件存储知识。技能编码流程。我按照 Anthropic Agent Skills 标准构建了 Agent 技能——结构化指令，告诉 AI 如何执行特定任务，并内置质量关卡。\n自动加载 vs. 手动调用：两种类型的技能解决两个不同的问题：\n参考技能（voice-guide、writing-anti-patterns）在 YAML 前置元数据中设置 user-invocable: false。Agent 读取描述字段，在任务涉及写作时自动注入它们。我从不调用它们，它们每次都静默激活。 任务技能（/write-blog、/topic-research、/content-workflow）设置 disable-model-invocation: true。Agent 不能自行触发它们。我输入斜杠命令，技能就成为 Agent 该任务的完整指令集。 自动加载解决了一致性问题。我不必每次要草稿时都记得说\"用我的语气\"。手动调用解决了精确性问题。研究任务有不同于博客文章的质量关卡。\n当我输入 /write-blog context engineering for marketing teams 时，五件事自动发生：语气指南加载（我如何写作），反模式加载（我绝不写什么），博客模板加载（7 节结构，带字数目标），检查 persona 文件夹中的受众画像，检查研究文件夹中的现有主题研究。一个斜杠命令触发完整的上下文组装。\n语气系统：我的语气被编码为结构化数据。语气档案在五个维度上用 1-10 评分：正式/随意（6）、严肃/活泼（4）、技术/简单（7）、保守/表达（6）、谦逊/自信（7）。反模式文件包含三个层级的 50+ 个禁用词、禁用开头、结构陷阱（强制三段论、系动词回避、过度对冲），以及每段最多一个破折号的硬性限制。\n大多数人用形容词描述自己的语气：“专业但平易近人。“这对 AI 毫无用处。技术/简单维度的 7 分精确告诉模型该落在哪里。禁用词列表更强大——定义你不是什么比定义你是什么更容易。\n4）操作系统：我如何在日常中使用它 内容管道：七个阶段——想法、研究、大纲、草稿、编辑、发布、推广。\n想法被捕获到 ideas.jsonl，带有评分系统：每个想法在定位契合度、独特洞见、受众需求、时效性、努力与影响比上评 1-5 分。总分达到 15 或以上才推进。 研究输出到知识模块。 草稿经过四轮编辑。 发布内容记录到 posts.jsonl，包含平台、URL 和参与度指标。 推广使用线程模板创建 X 公告和 LinkedIn 改编版。 我在周日批量创作内容：3-4 小时，目标产出 3-4 篇草稿和大纲。\n个人 CRM：联系人按四个圈子组织，维护节奏不同：内圈（每周）、活跃（每两周）、网络（每月）、休眠（每季度重新激活）。每条联系人记录都有 can_help_with 和 you_can_help_with 字段，支持介绍匹配系统。互动记录带有情感追踪（积极、中性、需要关注），让关系健康状况一目了然。\n自动化链：五个脚本处理重复工作流。周日每周回顾按顺序运行三个脚本：metrics_snapshot.py 更新数字，stale_contacts.py 标记关系，weekly_review.py 生成摘要文档，包含完成与计划对比、指标趋势和下周优先级。\n5）我犯的错误和我会怎么做不同 第一版过度设计了 Schema：我最初的 JSONL Schema 每条记录有 15+ 个字段，大多数是空的。Agent 在处理稀疏数据时会挣扎——它们试图填充字段或评论字段的缺失。我将 Schema 削减到 8-10 个必要字段，只在实际有数据时才添加可选字段。更简单的 Schema，更好的 Agent 行为。\n语气指南太长：第一版 tone-of-voice.md 有 1200 行。Agent 开头表现良好，然后到第四段就漂移了，因为语气指令落入了\"迷失在中间\"区域。我重构它，将最独特的模式（标志性短语、禁用词、开头模式）前置到前 100 行，扩展示例放在后面。关键规则需要在顶部，而不是中间。\n模块边界比你想象的更重要：我最初将身份和品牌放在一个模块里。Agent 在只需要禁用词列表时会加载我的整个简历。将它们拆分成两个模块，将仅语气任务的 token 使用量减少了 40%。每个模块边界都是一个加载决策。搞错了，你要么加载太多，要么太少。\n追加写入是不可妥协的：早期我因为 Agent 重写了 posts.jsonl 而不是追加，丢失了三个月的帖子参与数据。JSONL 的追加写入模式不只是惯例——它是一种安全机制。Agent 可以添加数据，不能销毁数据。这是系统中最重要的架构决策。\n6）结果与背后的原则 真正的结果比任何指标都简单。我打开 Cursor 或 Claude Code，开始对话，AI 已经知道我是谁、我如何写作、我在做什么、我关心什么。它用我的语气写作，因为我的语气被编码为结构化数据。它遵循我的优先级，因为我的目标在它建议下周工作内容之前读取的 YAML 文件里。它管理我的关系，因为我的联系人和互动在它可以查询的文件里。\n这背后的原则：这是上下文工程，而非提示词工程。\n提示词工程问的是\"我如何更好地措辞这个问题？“上下文工程问的是\"这个 AI 需要什么信息才能做出正确决策，以及我如何构建这些信息让模型真正使用它？”\n转变是从优化单次交互到设计信息架构。这是写一封好邮件和建立一个好归档系统之间的区别。前者帮你一次，后者每次都帮你。\n整个系统放在一个 Git 仓库里。克隆到任何机器，将任何 AI 工具指向它，操作系统就运行起来了。零依赖，完全可移植。因为是 Git，每次变更都有版本，每个决策都可追溯，没有什么是真正丢失的。\nMuratcan Koylan 是 Sully.ai 的 Context Engineer，为医疗 AI 设计上下文工程系统。他在上下文工程方面的开源工作（8000+ GitHub Star）被学术研究引用。框架开源地址：Agent Skills for Context Engineering\n","wordCount":"365","inLanguage":"en","image":"https://Lumicreator.github.io/lumi-tech-blog/images/personal-brain-os-cover.png","datePublished":"2026-02-23T16:00:00Z","dateModified":"2026-02-23T16:00:00Z","author":{"@type":"Person","name":"Lumi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Lumicreator.github.io/lumi-tech-blog/posts/personal-brain-os-translation/"},"publisher":{"@type":"Organization","name":"Lumi's Tech Blog","logo":{"@type":"ImageObject","url":"https://Lumicreator.github.io/lumi-tech-blog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://Lumicreator.github.io/lumi-tech-blog/ accesskey=h title="Lumi's Tech Blog (Alt + H)">Lumi's Tech Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Lumicreator.github.io/lumi-tech-blog/posts/ title=文章><span>文章</span></a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/categories/ title=分类><span>分类</span></a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/ title=标签><span>标签</span></a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Lumicreator.github.io/lumi-tech-blog/>Home</a>&nbsp;»&nbsp;<a href=https://Lumicreator.github.io/lumi-tech-blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">文件系统即数据库：我如何为 AI Agent 构建个人操作系统</h1><div class=post-description>全译 Muratcan Koylan 的爆款长文。用 Git 仓库 + 80+ 个 Markdown/YAML/JSONL 文件，打造一套让 AI 真正了解你的个人操作系统。</div><div class=post-meta><span title='2026-02-23 16:00:00 +0000 UTC'>February 23, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Lumi</span></div></header><figure class=entry-cover><img loading=eager src=https://Lumicreator.github.io/lumi-tech-blog/images/personal-brain-os-cover.png alt="Personal Brain OS"><figcaption>文件系统即数据库</figcaption></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98%e4%b8%8a%e4%b8%8b%e6%96%87%e8%80%8c%e9%9d%9e%e6%8f%90%e7%a4%ba%e8%af%8d aria-label=1）核心问题：上下文，而非提示词>1）核心问题：上下文，而非提示词</a></li><li><a href=#2%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%8d%b3%e8%ae%b0%e5%bf%86 aria-label=2）文件系统即记忆>2）文件系统即记忆</a></li><li><a href=#3%e6%8a%80%e8%83%bd%e7%b3%bb%e7%bb%9f%e6%95%99-ai-%e5%a6%82%e4%bd%95%e5%81%9a%e4%bd%a0%e7%9a%84%e5%b7%a5%e4%bd%9c aria-label="3）技能系统：教 AI 如何做你的工作">3）技能系统：教 AI 如何做你的工作</a></li><li><a href=#4%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%88%91%e5%a6%82%e4%bd%95%e5%9c%a8%e6%97%a5%e5%b8%b8%e4%b8%ad%e4%bd%bf%e7%94%a8%e5%ae%83 aria-label=4）操作系统：我如何在日常中使用它>4）操作系统：我如何在日常中使用它</a></li><li><a href=#5%e6%88%91%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af%e5%92%8c%e6%88%91%e4%bc%9a%e6%80%8e%e4%b9%88%e5%81%9a%e4%b8%8d%e5%90%8c aria-label=5）我犯的错误和我会怎么做不同>5）我犯的错误和我会怎么做不同</a></li><li><a href=#6%e7%bb%93%e6%9e%9c%e4%b8%8e%e8%83%8c%e5%90%8e%e7%9a%84%e5%8e%9f%e5%88%99 aria-label=6）结果与背后的原则>6）结果与背后的原则</a></li></ul></div></details></div><div class=post-content><blockquote><p><strong>译者注</strong>：本文翻译自 Muratcan Koylan（<a href=https://x.com/koylanai>@koylanai</a>）于 2026 年 2 月 21 日发布的长文 <em><a href=https://x.com/koylanai/status/2025286163641118915>The File System Is the New Database</a></em>。发布后迅速获得 110 万浏览、4000+ 点赞、12000+ 收藏。作者是 Sully.ai 的 Context Engineer，其开源 Context Engineering 框架在 GitHub 获得 8000+ Star。</p></blockquote><hr><p>每次 AI 对话都从同一个地方开始：你解释自己是谁，你在做什么，你粘贴进风格指南，你重新描述你的目标。你把昨天给过的上下文再给一遍，前天的再给一遍。然后，40 分钟后，模型忘记了你的语气，开始写得像新闻稿。</p><p>我受够了。所以我构建了一套系统来解决这个问题。</p><p>我称之为 <strong>Personal Brain OS</strong>（个人大脑操作系统）。这是一套基于文件的个人操作系统，存活在一个 Git 仓库里。克隆它，在 Cursor 或 Claude Code 中打开，AI 助手就拥有了一切：我的语气、我的品牌、我的目标、我的联系人、我的内容管道、我的研究、我的失败记录。</p><p>无需数据库，无需 API Key，无需构建步骤。只有 80+ 个 Markdown、YAML 和 JSONL 文件——人类和语言模型都能原生读取。</p><p>我将分享完整的架构、设计决策和踩过的坑，让你能构建自己的版本。不是我的复制品，而是你的。具体的模块、文件 Schema、技能定义会因你的工作而不同。但模式是可迁移的。为 AI Agent 构建信息结构的原则是通用的。</p><hr><h2 id=1核心问题上下文而非提示词>1）核心问题：上下文，而非提示词<a hidden class=anchor aria-hidden=true href=#1核心问题上下文而非提示词>#</a></h2><p>大多数人认为 AI 助手的瓶颈在于提示词工程。写更好的提示词，得到更好的答案。对于单次交互，这是对的。但当你想让 AI 在数周乃至数月内跨越数十个任务、以你的身份运作时，这套逻辑就崩了。</p><p><strong>注意力预算</strong>：语言模型有有限的上下文窗口，而且并非所有位置都同等重要。这意味着把你知道的一切都塞进系统提示词，不仅是浪费，还会主动降低性能。你添加的每一个 token 都在争夺模型的注意力。</p><p>我们的大脑也类似。当有人在会议前给你做 15 分钟简报，你会记住他们说的第一件事和最后一件事，中间的模糊了。语言模型有同样的 U 形注意力曲线，只不过它们的是数学上可测量的。Token 位置影响召回概率。新模型在改善，但你仍然在分散模型对最重要事物的注意力。</p><p>了解这一点，会改变你为 AI 系统设计信息架构的方式。</p><p><strong>模块化而非单一巨型提示词</strong>：我没有写一个庞大的系统提示词，而是将 Personal OS 拆分成 11 个独立模块。当我让 AI 写博客时，它加载我的语气指南和品牌文件。当我让它准备会议时，它加载我的联系人数据库和互动历史。模型在内容任务期间永远看不到网络数据，在会议准备任务期间永远看不到内容模板。</p><p><strong>渐进式披露</strong>：这是让整个系统运转的架构模式。我没有一次性加载所有 80+ 个文件，而是使用三个层级：</p><ul><li><strong>Level 1</strong>：一个轻量级路由文件，始终加载。它告诉 AI 哪个模块是相关的。</li><li><strong>Level 2</strong>：模块专属指令，仅在需要该模块时加载。</li><li><strong>Level 3</strong>：实际数据——JSONL 日志、YAML 配置、研究文档，仅在任务需要时加载。</li></ul><p>这三个层级创建了一个漏斗：广泛路由 → 模块上下文 → 具体数据。在每一步，模型都拥有它所需要的，仅此而已。</p><p>我的路由文件是 <code>SKILL.md</code>，它告诉 Agent &ldquo;这是内容任务，加载品牌模块"或"这是网络任务，加载联系人&rdquo;。模块指令文件（<code>CONTENT.md</code>、<code>OPERATIONS.md</code>、<code>NETWORK.md</code>）每个 40-100 行，包含文件清单、工作流序列和行为规则的 <code>&lt;instructions></code> 块。数据文件最后加载，仅在需要时。AI 逐行读取联系人，而不是解析整个文件。三个层级，到任何信息最多两跳。</p><p><strong>Agent 指令层级</strong>：我构建了三层指令，在不同层级限定 AI 的行为范围：</p><ul><li><strong>仓库层</strong>：<code>CLAUDE.md</code> 是入职文档——每个 AI 工具首先读取它，获得项目的完整地图。</li><li><strong>大脑层</strong>：<code>AGENT.md</code> 包含七条核心规则和一个决策表，将常见请求映射到精确的行动序列。</li><li><strong>模块层</strong>：每个目录都有自己的指令文件，包含领域专属的行为约束。</li></ul><p>这解决了大型 AI 项目中普遍存在的"指令冲突"问题。当所有内容都在一个系统提示词里时，规则会相互矛盾。通过将规则限定在其领域，你消除了冲突，给 Agent 提供了清晰、不重叠的指导。</p><hr><h2 id=2文件系统即记忆>2）文件系统即记忆<a hidden class=anchor aria-hidden=true href=#2文件系统即记忆>#</a></h2><p>我做出的最反直觉的决定之一：<strong>不用数据库</strong>。没有向量存储，没有检索系统，只有磁盘上的文件，用 Git 版本控制。</p><p><strong>格式-功能映射</strong>：系统中的每种文件格式都因特定原因而被选择：</p><ul><li><strong>JSONL 用于日志</strong>：天然追加写入，流式友好（Agent 逐行读取，无需解析整个文件），每行都是独立的有效 JSON。</li><li><strong>YAML 用于配置</strong>：干净处理层级数据，支持注释，人类和机器都可读，没有 JSON 括号的噪音。</li><li><strong>Markdown 用于叙述</strong>：LLM 原生读取，到处都能渲染，在 Git 中产生干净的 diff。</li></ul><p>JSONL 的追加写入特性防止了一类 bug——Agent 意外覆盖历史数据。我见过这种情况发生在 JSON 文件上：Agent 写入整个文件，丢失了三个月的联系人历史。用 JSONL，Agent 只能添加行。删除通过将条目标记为 <code>"status": "archived"</code> 来完成，保留完整历史以供模式分析。</p><p>我的系统使用 11 个 JSONL 文件（帖子、联系人、互动、书签、想法、指标、经历、决策、失败、参与度、会议），6 个 YAML 文件（目标、价值观、学习、圈子、节奏、启发式），以及 50+ 个 Markdown 文件（语气指南、研究、模板、草稿、待办）。每个 JSONL 文件都以 Schema 行开头：<code>{"_schema": "contact", "_version": "1.0", "_description": "..."}</code>。Agent 在读取数据之前始终知道结构。</p><p><strong>情节记忆</strong>：大多数"第二大脑"系统存储事实。我的还存储判断。<code>memory/</code> 模块包含三个追加写入日志：</p><ul><li><code>experiences.jsonl</code>：关键时刻，带有 1-10 的情感权重评分</li><li><code>decisions.jsonl</code>：关键决策，包含推理、考虑的替代方案和追踪的结果</li><li><code>failures.jsonl</code>：出了什么问题、根本原因和预防步骤</li></ul><p>拥有你的文件的 AI 和拥有你的判断的 AI 之间有区别。事实告诉 Agent 发生了什么。情节记忆告诉 Agent 什么是重要的、我会怎么做不同、以及我如何权衡取舍。</p><p><strong>跨模块引用</strong>：系统使用扁平文件关系模型。没有数据库，但结构化程度足以让 Agent 跨文件连接数据。<code>interactions.jsonl</code> 中的 <code>contact_id</code> 指向 <code>contacts.jsonl</code> 中的条目。<code>ideas.jsonl</code> 中的 <code>pillar</code> 映射到 <code>identity/brand.md</code> 中定义的内容支柱。书签喂给内容想法，帖子指标喂给每周回顾。</p><hr><h2 id=3技能系统教-ai-如何做你的工作>3）技能系统：教 AI 如何做你的工作<a hidden class=anchor aria-hidden=true href=#3技能系统教-ai-如何做你的工作>#</a></h2><p>文件存储知识。技能编码流程。我按照 Anthropic Agent Skills 标准构建了 Agent 技能——结构化指令，告诉 AI 如何执行特定任务，并内置质量关卡。</p><p><strong>自动加载 vs. 手动调用</strong>：两种类型的技能解决两个不同的问题：</p><ul><li><strong>参考技能</strong>（<code>voice-guide</code>、<code>writing-anti-patterns</code>）在 YAML 前置元数据中设置 <code>user-invocable: false</code>。Agent 读取描述字段，在任务涉及写作时自动注入它们。我从不调用它们，它们每次都静默激活。</li><li><strong>任务技能</strong>（<code>/write-blog</code>、<code>/topic-research</code>、<code>/content-workflow</code>）设置 <code>disable-model-invocation: true</code>。Agent 不能自行触发它们。我输入斜杠命令，技能就成为 Agent 该任务的完整指令集。</li></ul><p>自动加载解决了一致性问题。我不必每次要草稿时都记得说"用我的语气"。手动调用解决了精确性问题。研究任务有不同于博客文章的质量关卡。</p><p>当我输入 <code>/write-blog context engineering for marketing teams</code> 时，五件事自动发生：语气指南加载（我如何写作），反模式加载（我绝不写什么），博客模板加载（7 节结构，带字数目标），检查 persona 文件夹中的受众画像，检查研究文件夹中的现有主题研究。一个斜杠命令触发完整的上下文组装。</p><p><strong>语气系统</strong>：我的语气被编码为结构化数据。语气档案在五个维度上用 1-10 评分：正式/随意（6）、严肃/活泼（4）、技术/简单（7）、保守/表达（6）、谦逊/自信（7）。反模式文件包含三个层级的 50+ 个禁用词、禁用开头、结构陷阱（强制三段论、系动词回避、过度对冲），以及每段最多一个破折号的硬性限制。</p><p>大多数人用形容词描述自己的语气：&ldquo;专业但平易近人。&ldquo;这对 AI 毫无用处。技术/简单维度的 7 分精确告诉模型该落在哪里。禁用词列表更强大——定义你不是什么比定义你是什么更容易。</p><hr><h2 id=4操作系统我如何在日常中使用它>4）操作系统：我如何在日常中使用它<a hidden class=anchor aria-hidden=true href=#4操作系统我如何在日常中使用它>#</a></h2><p><strong>内容管道</strong>：七个阶段——想法、研究、大纲、草稿、编辑、发布、推广。</p><ul><li>想法被捕获到 <code>ideas.jsonl</code>，带有评分系统：每个想法在定位契合度、独特洞见、受众需求、时效性、努力与影响比上评 1-5 分。总分达到 15 或以上才推进。</li><li>研究输出到知识模块。</li><li>草稿经过四轮编辑。</li><li>发布内容记录到 <code>posts.jsonl</code>，包含平台、URL 和参与度指标。</li><li>推广使用线程模板创建 X 公告和 LinkedIn 改编版。</li></ul><p>我在周日批量创作内容：3-4 小时，目标产出 3-4 篇草稿和大纲。</p><p><strong>个人 CRM</strong>：联系人按四个圈子组织，维护节奏不同：内圈（每周）、活跃（每两周）、网络（每月）、休眠（每季度重新激活）。每条联系人记录都有 <code>can_help_with</code> 和 <code>you_can_help_with</code> 字段，支持介绍匹配系统。互动记录带有情感追踪（积极、中性、需要关注），让关系健康状况一目了然。</p><p><strong>自动化链</strong>：五个脚本处理重复工作流。周日每周回顾按顺序运行三个脚本：<code>metrics_snapshot.py</code> 更新数字，<code>stale_contacts.py</code> 标记关系，<code>weekly_review.py</code> 生成摘要文档，包含完成与计划对比、指标趋势和下周优先级。</p><hr><h2 id=5我犯的错误和我会怎么做不同>5）我犯的错误和我会怎么做不同<a hidden class=anchor aria-hidden=true href=#5我犯的错误和我会怎么做不同>#</a></h2><ul><li><p><strong>第一版过度设计了 Schema</strong>：我最初的 JSONL Schema 每条记录有 15+ 个字段，大多数是空的。Agent 在处理稀疏数据时会挣扎——它们试图填充字段或评论字段的缺失。我将 Schema 削减到 8-10 个必要字段，只在实际有数据时才添加可选字段。更简单的 Schema，更好的 Agent 行为。</p></li><li><p><strong>语气指南太长</strong>：第一版 <code>tone-of-voice.md</code> 有 1200 行。Agent 开头表现良好，然后到第四段就漂移了，因为语气指令落入了"迷失在中间"区域。我重构它，将最独特的模式（标志性短语、禁用词、开头模式）前置到前 100 行，扩展示例放在后面。关键规则需要在顶部，而不是中间。</p></li><li><p><strong>模块边界比你想象的更重要</strong>：我最初将身份和品牌放在一个模块里。Agent 在只需要禁用词列表时会加载我的整个简历。将它们拆分成两个模块，将仅语气任务的 token 使用量减少了 40%。每个模块边界都是一个加载决策。搞错了，你要么加载太多，要么太少。</p></li><li><p><strong>追加写入是不可妥协的</strong>：早期我因为 Agent 重写了 <code>posts.jsonl</code> 而不是追加，丢失了三个月的帖子参与数据。JSONL 的追加写入模式不只是惯例——它是一种安全机制。Agent 可以添加数据，不能销毁数据。这是系统中最重要的架构决策。</p></li></ul><hr><h2 id=6结果与背后的原则>6）结果与背后的原则<a hidden class=anchor aria-hidden=true href=#6结果与背后的原则>#</a></h2><p>真正的结果比任何指标都简单。我打开 Cursor 或 Claude Code，开始对话，AI 已经知道我是谁、我如何写作、我在做什么、我关心什么。它用我的语气写作，因为我的语气被编码为结构化数据。它遵循我的优先级，因为我的目标在它建议下周工作内容之前读取的 YAML 文件里。它管理我的关系，因为我的联系人和互动在它可以查询的文件里。</p><p>这背后的原则：<strong>这是上下文工程，而非提示词工程。</strong></p><p>提示词工程问的是"我如何更好地措辞这个问题？&ldquo;上下文工程问的是"这个 AI 需要什么信息才能做出正确决策，以及我如何构建这些信息让模型真正使用它？&rdquo;</p><p>转变是从优化单次交互到设计信息架构。这是写一封好邮件和建立一个好归档系统之间的区别。前者帮你一次，后者每次都帮你。</p><p>整个系统放在一个 Git 仓库里。克隆到任何机器，将任何 AI 工具指向它，操作系统就运行起来了。零依赖，完全可移植。因为是 Git，每次变更都有版本，每个决策都可追溯，没有什么是真正丢失的。</p><hr><p><em>Muratcan Koylan 是 <a href=https://sully.ai>Sully.ai</a> 的 Context Engineer，为医疗 AI 设计上下文工程系统。他在上下文工程方面的开源工作（8000+ GitHub Star）被学术研究引用。框架开源地址：<a href=https://github.com/muratcankoylan/Agent-Skills-for-Context-Engineering>Agent Skills for Context Engineering</a></em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/ai/>AI</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/context-engineering/>Context Engineering</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/agent/>Agent</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/translation/>Translation</a></li><li><a href=https://Lumicreator.github.io/lumi-tech-blog/tags/personal-os/>Personal OS</a></li></ul><nav class=paginav><a class=prev href=https://Lumicreator.github.io/lumi-tech-blog/posts/cliproxy-gemini-image-gen/><span class=title>« Prev</span><br><span>用 CLIProxyAPI 反代 Gemini，让任何工具都能 AI 生图</span>
</a><a class=next href=https://Lumicreator.github.io/lumi-tech-blog/posts/notebooklm-vps-headed-login-fix/><span class=title>Next »</span><br><span>NotebookLM 在 VPS 上无法使用？一篇讲清：有头登录 + 持久化会话的完整修复</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://Lumicreator.github.io/lumi-tech-blog/>Lumi's Tech Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
mermaid.initialize({ startOnLoad: true, theme: 'default' });
</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>